volatile
1.1 特性 ： 可以保证可见性，有序性 但无法保证原子性
1.2 读写的内存语义
    简单来说，每个线程都有自己的本地内存，执行某项任务时，会从共享内存中读取数据到本地，被volatile修饰的变量会使本地存储的变量无效
    读：当线程读一个volatile修饰的变量时，jmm会把该线程对应的本地内存中的变量设为无效，从主存中读取
    写：jmm会把该线程对应的本地内存中的共享变量刷新到主内存
2.语义实现原理
2.1 volatile可见性实现原理
    常识：任何一门语言都需要转换为平台相关的汇编指令才能最终被硬件执行 不同系列的cpu架构不同，所以汇编指令也不相同
          如果直接将源程序编译成与平台相关的汇编指令，那么跨平台性会大打折扣
          为了实现平台无关性，java的编译器javac并不是将java的源程序直接编译成与平台相关的汇编指令，二四号编译成一种中间语言即java的class字节码文件
          所谓的字节码文件，存储的就是一个一个的字节，十六进制表示，java源码编译之后的字节码文件是无法被cpu执行的，由jvm
          为了让java能在不同的平台上运行，java官方提供了针对不同平台的java虚拟机，jvm运行于硬件之上，屏蔽平台的差异
          **javac编译后的字节码文件由jvm加载，最后转化为与硬件相关的汇编指令由cpu执行
    总结：volatile可见性的实现就是借助cpu的lock指令，通过在写volatile的机器指令前加上lock前缀，使写volatile具有两个原则：
         1.写volatile时处理器会把缓存写回到主内存
         2.一个处理器缓存写到主内存会使其他处理器缓存无效（缓存一致性）
2.2 volatile有序性实现原理
